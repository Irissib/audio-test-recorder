<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>WebRTC Audio Test</title>
<style>
body { font-family: sans-serif; padding: 20px; }
button { margin: 5px; padding: 10px 20px; font-size: 16px; }
#meter { width: 200px; height: 16px; background: #ddd; margin-top: 10px; }
#bar { height: 100%; width: 0%; background: #999; }
</style>
</head>
<body>

<h2>WebRTC Audio-Test</h2>
<p>Sprich bitte ein langes "aaahhh" und danach ein langes "iiihhh".</p>

<select id="audioInputSelect"></select><br>

<button id="btnStart" disabled>START</button>
<button id="btnStop" disabled>STOP</button>

<div id="meter"><div id="bar"></div></div>
<p id="meterStatus">Bitte normal sprechen...</p>

<div id="audioPlayerContainer"></div>

<script>
let mediaRecorder, microphone;
let audioChunks = [];
let audioCtx, analyser, dataArray;
let timerInterval = null;
let recordSeconds = 0;

const btnStart = document.getElementById("btnStart");
const btnStop = document.getElementById("btnStop");
const audioSelect = document.getElementById("audioInputSelect");
const meterBar = document.getElementById("bar");
const meterStatus = document.getElementById("meterStatus");
const playerContainer = document.getElementById("audioPlayerContainer");

// GerÃ¤te auflisten
async function listAudioDevices() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  audioSelect.innerHTML = '';
  devices.forEach(d => {
    if(d.kind === 'audioinput') {
      const opt = document.createElement('option');
      opt.value = d.deviceId;
      opt.text = d.label || 'Mikrofon';
      audioSelect.appendChild(opt);
    }
  });
}

async function captureMicrophone() {
  if(microphone) {
    return microphone;
  }
  const stream = await navigator.mediaDevices.getUserMedia({
    audio: {
      deviceId: audioSelect.value ? { exact: audioSelect.value } : undefined,
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      channelCount: 1,
      sampleRate: 48000
    }
  });
  microphone = stream;
  return stream;
}

function initMeter(stream) {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const source = audioCtx.createMediaStreamSource(stream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 512;
  dataArray = new Float32Array(analyser.fftSize);
  source.connect(analyser);
  meterLoop();
}

function meterLoop() {
  if(!analyser) return;
  analyser.getFloatTimeDomainData(dataArray);
  let rms = 0;
  for(let i=0;i<dataArray.length;i++) rms += dataArray[i]*dataArray[i];
  rms = Math.sqrt(rms/dataArray.length);
  let dB = 20*Math.log10(rms + 1e-12);
  let pct = Math.min(100, Math.max(0, (dB+60)/54*100));
  meterBar.style.width = pct + "%";
  if(dB > -6) { meterBar.style.background="#f66"; meterStatus.textContent="Zu laut!"; }
  else if(dB < -30) { meterBar.style.background="#f66"; meterStatus.textContent="Zu leise."; }
  else { meterBar.style.background="#6f6"; meterStatus.textContent="Pegel ok."; }
  requestAnimationFrame(meterLoop);
}

btnStart.onclick = async () => {
  btnStart.disabled = true;
  const stream = await captureMicrophone();
  initMeter(stream);
  audioChunks = [];

  mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
  mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
  mediaRecorder.onstop = () => {
    const blob = new Blob(audioChunks, { type: 'audio/webm' });
    const url = URL.createObjectURL(blob);
    playerContainer.innerHTML = '';
    const player = document.createElement('audio');
    player.controls = true;
    player.autoplay = true;
    player.src = url;
    playerContainer.appendChild(player);
  };

  mediaRecorder.start();
  btnStop.disabled = false;

  recordSeconds = 0;
  timerInterval = setInterval(() => {
    recordSeconds++;
    btnStart.textContent = `Aufnahme... ${recordSeconds}s`;
  }, 1000);
};

btnStop.onclick = () => {
  if(mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
    clearInterval(timerInterval);
    btnStart.textContent = 'START';
    btnStop.disabled = true;
    btnStart.disabled = false;
  }
};

listAudioDevices().then(async () => {
  audioSelect.onchange = async () => {
    if(microphone) {
      microphone.getTracks().forEach(t => t.stop());
      microphone = null;
    }
    btnStart.disabled = true;
    await captureMicrophone();
    btnStart.disabled = false;
  };
  await captureMicrophone();
  btnStart.disabled = false;
});
</script>

</body>
</html>

